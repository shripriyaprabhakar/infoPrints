// Generated by CoffeeScript 1.10.0
var coerceEntry, coerceQuery, coerceQueryKey, coerceQueryValue, key_map, makeUrl, request, search, unique, xml2js;

request = require('request');

xml2js = require('xml2js');

makeUrl = function(query, max_results, sort_by) {
  if (max_results == null) {
    max_results = 1000;
  }
  if (sort_by == null) {
    sort_by = 'submittedDate';
  }
  return "http://export.arxiv.org/api/query?sortBy=" + sort_by + "&max_results=" + max_results + "&search_query=" + query;
};

key_map = {
  author: 'au',
  q: 'all',
  title: 'ti',
  category: 'cat'
};

coerceQueryKey = function(key) {
  return key_map[key] || key;
};

coerceQueryValue = function(key, value) {
  var matched;
  if (key === 'au') {
    if (matched = value.match(/^(\w+).* (\w+)$/)) {
      return matched[2] + '_' + matched[1][0];
    } else {
      return value;
    }
  } else {
    return value;
  }
};

coerceQuery = function(query) {
  var k, querys, v;
  querys = [];
  for (k in query) {
    v = query[k];
    k = coerceQueryKey(k);
    v = coerceQueryValue(k, v);
    querys.push([k, v].join(':'));
  }
  return querys.join('+AND+');
};

unique = function(a, k) {
  var a_, i, j, known, len;
  a_ = [];
  known = {};
  for (j = 0, len = a.length; j < len; j++) {
    i = a[j];
    if (!known[i[k]]) {
      known[i[k]] = true;
      a_.push(i);
    }
  }
  return a_;
};

coerceEntry = function(entry) {
  return {
    id: entry.id[0],
    updated: new Date(entry.updated[0]),
    published: new Date(entry.published[0]),
    title: entry.title[0].trim().replace(/\s+/g, ' '),
    summary: entry.summary[0].trim().replace(/\s+/g, ' '),
    links: entry.link.map(function(link) {
      return {
        href: link['$']['href'],
        title: link['$']['title']
      };
    }),
    authors: unique(entry.author.map(function(author) {
      return {
        name: author['name'][0]
      };
    }), 'name'),
    categories: entry.category.map(function(category) {
      return category['$']['term'];
    })
  };
};

search = function(query, cb) {
  return request.get(makeUrl(coerceQuery(query)), function(err, resp, data) {
    return xml2js.parseString(data, function(err, parsed) {
      var items, ref, ref1, total;
      if (err != null) {
        return cb(err);
      } else {
        items = parsed != null ? (ref = parsed.feed) != null ? (ref1 = ref.entry) != null ? ref1.map(coerceEntry) : void 0 : void 0 : void 0;
        items || (items = []);
        total = Number(parsed.feed['opensearch:totalResults'][0]['_']);
        total || (total = 0);
        return cb(err, {
          items: items,
          total: total
        });
      }
    });
  });
};

module.exports = {
  search: search
};
